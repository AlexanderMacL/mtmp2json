%% Function to create MTM profile file from JSON encoded data
%
% 
% Usage
%   json2mtmp() - a file open dialog is provided to open *.json file and to
%       save *.mtmp file. To be used at the command line or as a standalone
%       script.
%   json2mtmp(J) - the MATLAB data structure J containing the relevant
%       fields is used in place of the *.json file, and the output file is
%       saved to the location given by J.outFileLocation
%   json2mtmp(infileloc, outfileloc) - the character vectors infileloc and
%       outfileloc respectively contain the locations of the desired input
%       (JSON) and output (mtmp) files.
% 
% Notes
%   The mapper step should never come last
%   See commented example JSON file for allowed fields, or use accompanying
%   function mtmp2json to decode an existing mtmp
%   


function json2mtmp(varargin)

% Values for SRR step (for Traction) and speed step (for Stribeck) are sent
% to the MTM as integers, and read *10^(-n) where n = intCodedRealPrecision
intCodedRealPrecision = 3;

if (nargin==0)
    % open input file
    [flnm,pth,~] = uigetfile({'*.json','JavaScript Object Notation Files (*.json)';'*.*','All Files (*.*)'});
    f = fopen([pth,flnm]);
    raw = fread(f, inf);
    txt = char(raw');
    fclose(f);
    % decode JSON
    J = jsondecode(txt);
    
elseif (nargin==1)
    J = varargin{1};
    
elseif (nargin==2)
    % open input file
    f = fopen(varargin{1});
    raw = fread(f, inf);
    txt = char(raw');
    fclose(f);
    % decode JSON
    J = jsondecode(txt);
    
elseif (nargin>2)
    error("Too many arguments (%d given)",nargin);

end

% open output file
if (nargin==2)
    flnm = varargin{2};
    f = fopen(flnm,"w");
else
    [flnm,pth,~] = uiputfile({'*.mtmp','MTM Profile Files (*.mtmp)';'*.etmp','ETM Profile Files (*.etmp)';'*.*','All Files (*.*)'},'Save File',flnm(1:length(flnm)-5));
    f = fopen([pth,flnm],"w");
end
mtm_etm = flnm(length(flnm)-3);


% Construct byte arrays
if (mtm_etm == 'e')
    Header = [0x1, zeros(1,15), ...
        length(J.Name)];
    if (length(J.Name)>127); Header = [Header, 0x01]; end
    Header = [Header, uint8(J.Name), ...
        typecast(uint32(length(J.Steps)), 'uint8')];
else
    Header = [0x1, zeros(1,19), ...
        typecast(4.0, 'uint8'), typecast(20.0, 'uint8'), ... // are PCS weedy?
        0x1, 0x35, length(J.Name)];
    if (length(J.Name)>127); Header = [Header, 0x01]; end
    Header = [Header, uint8(J.Name), ...
        typecast(uint32(length(J.Steps)), 'uint8')];
end

if (~ iscell(J.Steps))
    J.Steps = num2cell(J.Steps);
end

for i = 1:length(J.Steps)
    lubeProbe = strcmpi(J.Steps{i}.tempCtrlProbe,'lube');
    if (mtm_etm~='e') % ETM has no ECR
        if (strcmpi(J.Steps{i}.ECRoption,'A') || strcmpi(J.Steps{i}.ECRoption,'10'))
            ECR = 0x0;
        elseif (strcmpi(J.Steps{i}.ECRoption,'B') || strcmpi(J.Steps{i}.ECRoption,'100'))
            ECR = 0x1;
        elseif (strcmpi(J.Steps{i}.ECRoption,'C') || strcmpi(J.Steps{i}.ECRoption,'1k') || strcmpi(J.Steps{i}.ECRoption,'1000'))
            ECR = 0x2;
        elseif (strcmpi(J.Steps{i}.ECRoption,'D') || strcmpi(J.Steps{i}.ECRoption,'10k') || strcmpi(J.Steps{i}.ECRoption,'10000'))
            ECR = 0x3;
        elseif (strcmpi(J.Steps{i}.ECRoption,'none'))
            ECR = 0x4;
        else
            error("ECRoption """ + J.Steps{i}.ECRoption + """ unsupported"+newline+...
                char(9)+" supported values of ECRoption are 'A', '10', 'B', '100', 'C', '1k', 'D', '10k' and 'none'");
        end
    end
    % Traction step
    if (strcmpi(J.Steps{i}.stepType,'Traction'))
        disp("Step "+num2str(i)+" Traction");
        if (~ iscell(J.Steps{i}.SRRsteps))
            J.Steps{i}.SRRsteps = {J.Steps{i}.SRRsteps};
        end
        numsteps(i) = length(J.Steps{i}.SRRsteps);
        StepHeadBytes = [typecast(uint32(0), 'uint8'), typecast(uint32(1), 'uint8')];
        Step{i} = [StepHeadBytes, ...
            typecast(uint32(i), 'uint8'), typecast(uint32(length(J.Steps)), 'uint8'), ...
            length(J.Steps{i}.stepName), uint8(J.Steps{i}.stepName), ...
            J.Steps{i}.tempCtrlEn, typecast(uint32(lubeProbe), 'uint8'), ...
            typecast(double(J.Steps{i}.tempCtrlTemp), 'uint8'), ...
            J.Steps{i}.waitForTempBeforeStep, ...
            typecast(double(J.Steps{i}.idleSpeed), 'uint8'), ...
            typecast(double(J.Steps{i}.idleLoad), 'uint8'), ...
            typecast(double(J.Steps{i}.idleSRR), 'uint8'), ...
            J.Steps{i}.unloadAtEnd
        ];
        if (mtm_etm ~= 'e'); Step{i} = [Step{i}, ECR, zeros(1,3)]; end % ETM has no ECR
        Step{i} = [Step{i}, 0x1, zeros(1,7), ...
            J.Steps{i}.measDiscTrackRadBeforeStep, ...
            typecast(double(J.Steps{i}.stepLoad), 'uint8'), ...
            typecast(double(J.Steps{i}.stepSpeed), 'uint8'), ...
            typecast(uint32(1), 'uint8'), typecast(uint32(length(J.Steps{i}.SRRsteps)), 'uint8')
        ];
        
        for j = 1:numsteps(i)
            if (strcmpi(J.Steps{i}.SRRsteps{j}.type,'linear increments') || strcmpi(J.Steps{i}.SRRsteps{j}.type,'lininc'))
                disp(char(9)+"SRR step "+num2str(j)+" linear increments");
                ns = double(J.Steps{i}.SRRsteps{j}.endSRR-J.Steps{i}.SRRsteps{j}.startSRR)/double(J.Steps{i}.SRRsteps{j}.incrementSRR);
                if (floor(ns)~=ns) % if not integer
                    warning("SRR increment does not result in integer of steps")
                end
                step{i,j} = [typecast(uint32(1), 'uint8'), ...
                    typecast(int64(J.Steps{i}.SRRsteps{j}.startSRR*(10^intCodedRealPrecision)), 'uint8'), ...
                    zeros(1,6), typecast(uint16(intCodedRealPrecision), 'uint8'), ...
                    typecast(int64(J.Steps{i}.SRRsteps{j}.endSRR*(10^intCodedRealPrecision)), 'uint8'), ...
                    zeros(1,6), typecast(uint16(intCodedRealPrecision), 'uint8'), ...
                    typecast(int64(J.Steps{i}.SRRsteps{j}.incrementSRR*(10^intCodedRealPrecision)), 'uint8'), ...
                    zeros(1,6), typecast(uint16(intCodedRealPrecision), 'uint8'), ...
                    uint8(ns), zeros(1,8)
                ];
            elseif (strcmpi(J.Steps{i}.SRRsteps{j}.type,'linear # steps') || strcmpi(J.Steps{i}.SRRsteps{j}.type,'linstep'))
                disp(char(9)+"SRR step "+num2str(j)+" linear # steps");
                J.Steps{i}.SRRsteps{j}.incrementSRR = double(J.Steps{i}.SRRsteps{j}.endSRR-J.Steps{i}.SRRsteps{j}.startSRR)/double(J.Steps{i}.SRRsteps{j}.numSteps);
                step{i,j} = [typecast(uint32(1), 'uint8'), ...
                    typecast(int64(J.Steps{i}.SRRsteps{j}.startSRR*(10^intCodedRealPrecision)), 'uint8'), ...
                    zeros(1,6), typecast(uint16(intCodedRealPrecision), 'uint8'), ...
                    typecast(int64(J.Steps{i}.SRRsteps{j}.endSRR*(10^intCodedRealPrecision)), 'uint8'), ...
                    zeros(1,6), typecast(uint16(intCodedRealPrecision), 'uint8'), ...
                    typecast(int64(J.Steps{i}.SRRsteps{j}.incrementSRR*(10^intCodedRealPrecision)), 'uint8'), ...
                    zeros(1,6), typecast(uint16(intCodedRealPrecision), 'uint8'), ...
                    J.Steps{i}.SRRsteps{j}.numSteps, zeros(1,4), 0x1, zeros(1,3)
                ];
            elseif (strcmpi(J.Steps{i}.SRRsteps{j}.type,'logarithmic') || strcmpi(J.Steps{i}.SRRsteps{j}.type,'log'))
                disp(char(9)+"SRR step "+num2str(j)+" logarithmic");
                step{i,j} = [typecast(uint32(1), 'uint8'), ...
                    typecast(int64(J.Steps{i}.SRRsteps{j}.startSRR*(10^intCodedRealPrecision)), 'uint8'), ...
                    zeros(1,6), typecast(uint16(intCodedRealPrecision), 'uint8'), ...
                    typecast(int64(J.Steps{i}.SRRsteps{j}.endSRR*(10^intCodedRealPrecision)), 'uint8'), ...
                    zeros(1,6), typecast(uint16(intCodedRealPrecision), 'uint8'), ...
                    zeros(1,16), J.Steps{i}.SRRsteps{j}.numSteps, zeros(1,3), 0x1, 0x1, zeros(1,3)
                ];
            else
                error("SRRstep type """ + J.Steps{i}.SRRsteps{j}.type + """ unsupported"+newline+...
                    char(9)+" supported values of Steps.SRRsteps.type are 'linstep', 'linear # steps', 'lininc', 'linear increments', 'log' and 'logarithmic'");
            end
        end
    % Stribeck step
    elseif (strcmpi(J.Steps{i}.stepType,'Stribeck'))
        disp("Step "+num2str(i)+" Stribeck");
        if (~ iscell(J.Steps{i}.speedSteps))
            J.Steps{i}.speedSteps = {J.Steps{i}.speedSteps};
        end
        numsteps(i) = length(J.Steps{i}.speedSteps);
        StepHeadBytes = [typecast(uint32(1), 'uint8'), typecast(uint32(1), 'uint8')];
        Step{i} = [StepHeadBytes, ...
            typecast(uint32(i), 'uint8'), typecast(uint32(length(J.Steps)), 'uint8'), ...
            length(J.Steps{i}.stepName), uint8(J.Steps{i}.stepName), ...
            J.Steps{i}.tempCtrlEn, typecast(uint32(lubeProbe), 'uint8'), ...
            typecast(double(J.Steps{i}.tempCtrlTemp), 'uint8'), ...
            J.Steps{i}.waitForTempBeforeStep, ...
            typecast(double(J.Steps{i}.idleSpeed), 'uint8'), ...
            typecast(double(J.Steps{i}.idleLoad), 'uint8'), ...
            typecast(double(J.Steps{i}.idleSRR), 'uint8'), ...
            J.Steps{i}.unloadAtEnd
        ];
        if (mtm_etm ~= 'e'); Step{i} = [Step{i}, ECR, zeros(1,3)]; end % ETM has no ECR
        Step{i} = [Step{i}, 0x1, zeros(1,7), ...
            J.Steps{i}.measDiscTrackRadBeforeStep, ...
            typecast(double(J.Steps{i}.stepLoad), 'uint8'), ...
            typecast(double(J.Steps{i}.stepSRR), 'uint8'), ...
            typecast(uint32(1), 'uint8'), typecast(uint32(length(J.Steps{i}.speedSteps)), 'uint8')
        ];
        
        for j = 1:numsteps(i)
            if (strcmpi(J.Steps{i}.speedSteps{j}.type,'linear increments') || strcmpi(J.Steps{i}.speedSteps{j}.type,'lininc'))
                disp(char(9)+"Speed step "+num2str(j)+" linear increments");
                ns = double(J.Steps{i}.speedSteps{j}.endSpeed-J.Steps{i}.speedSteps{j}.startSpeed)/double(J.Steps{i}.speedSteps{j}.incrementSpeed);
                if (floor(ns)~=ns) % if not integer
                    warning("Speed increment does not result in integer of steps")
                end
                step{i,j} = [typecast(uint32(1), 'uint8'), ...
                    typecast(int64(J.Steps{i}.speedSteps{j}.startSpeed*(10^intCodedRealPrecision)), 'uint8'), ...
                    zeros(1,6), typecast(uint16(intCodedRealPrecision), 'uint8'), ...
                    typecast(int64(J.Steps{i}.speedSteps{j}.endSpeed*(10^intCodedRealPrecision)), 'uint8'), ...
                    zeros(1,6), typecast(uint16(intCodedRealPrecision), 'uint8'), ...
                    typecast(int64(J.Steps{i}.speedSteps{j}.incrementSpeed*(10^intCodedRealPrecision)), 'uint8'), ...
                    zeros(1,6), typecast(uint16(intCodedRealPrecision), 'uint8'), ...
                    uint8(ns), zeros(1,8)
                ];
            elseif (strcmpi(J.Steps{i}.speedSteps{j}.type,'linear # steps') || strcmpi(J.Steps{i}.speedSteps{j}.type,'linstep'))
                disp(char(9)+"Speed step "+num2str(j)+" linear # steps");
                J.Steps{i}.speedSteps{j}.incrementSpeed = double(J.Steps{i}.speedSteps{j}.endSpeed-J.Steps{i}.speedSteps{j}.startSpeed)/double(J.Steps{i}.speedSteps{j}.numSteps);
                step{i,j} = [typecast(uint32(1), 'uint8'), ...
                    typecast(int64(J.Steps{i}.speedSteps{j}.startSpeed*(10^intCodedRealPrecision)), 'uint8'), ...
                    zeros(1,6), typecast(uint16(intCodedRealPrecision), 'uint8'), ...
                    typecast(int64(J.Steps{i}.speedSteps{j}.endSpeed*(10^intCodedRealPrecision)), 'uint8'), ...
                    zeros(1,6), typecast(uint16(intCodedRealPrecision), 'uint8'), ...
                    typecast(int64(J.Steps{i}.speedSteps{j}.incrementSpeed*(10^intCodedRealPrecision)), 'uint8'), ...
                    zeros(1,6), typecast(uint16(intCodedRealPrecision), 'uint8'), ...
                    J.Steps{i}.speedSteps{j}.numSteps, zeros(1,4), 0x1, zeros(1,3)
                ];
            elseif (strcmpi(J.Steps{i}.speedSteps{j}.type,'logarithmic') || strcmpi(J.Steps{i}.speedSteps{j}.type,'log'))
                disp(char(9)+"Speed step "+num2str(j)+" logarithmic");
                step{i,j} = [typecast(uint32(1), 'uint8'), ...
                    typecast(int64(J.Steps{i}.speedSteps{j}.startSpeed*(10^intCodedRealPrecision)), 'uint8'), ...
                    zeros(1,6), typecast(uint16(intCodedRealPrecision), 'uint8'), ...
                    typecast(int64(J.Steps{i}.speedSteps{j}.endSpeed*(10^intCodedRealPrecision)), 'uint8'), ...
                    zeros(1,6), typecast(uint16(intCodedRealPrecision), 'uint8'), ...
                    zeros(1,16), J.Steps{i}.speedSteps{j}.numSteps, zeros(1,3), 0x1, 0x1, zeros(1,3)
                ];
            else
                error("speedStep type """ + J.Steps{i}.speedSteps{j}.type + """ unsupported"+newline+...
                    char(9)+" supported values of Steps.SRRsteps.type are 'linstep', 'linear # steps', 'lininc', 'linear increments', 'log' and 'logarithmic'");
            end
        end
    % Bidirectional Traction step
    elseif (strcmpi(J.Steps{i}.stepType,'Bidirectional Traction'))
        disp("Step "+num2str(i)+" Bidirectional Traction");
        if (~ iscell(J.Steps{i}.SRRsteps))
            J.Steps{i}.SRRsteps = {J.Steps{i}.SRRsteps};
        end
        numsteps(i) = length(J.Steps{i}.SRRsteps);
        StepHeadBytes = [typecast(uint32(10), 'uint8'), typecast(uint32(1), 'uint8')];
        Step{i} = [StepHeadBytes, ...
            typecast(uint32(i), 'uint8'), typecast(uint32(length(J.Steps)), 'uint8'), ...
            length(J.Steps{i}.stepName), uint8(J.Steps{i}.stepName), ...
            J.Steps{i}.tempCtrlEn, typecast(uint32(lubeProbe), 'uint8'), ...
            typecast(double(J.Steps{i}.tempCtrlTemp), 'uint8'), ...
            J.Steps{i}.waitForTempBeforeStep, ...
            typecast(double(J.Steps{i}.idleSpeed), 'uint8'), ...
            typecast(double(J.Steps{i}.idleLoad), 'uint8'), ...
            typecast(double(J.Steps{i}.idleSRR), 'uint8'), ...
            J.Steps{i}.unloadAtEnd, ECR, zeros(1,3), 0x1, zeros(1,7), ... % J.Steps{i}.measDiscTrackRadBeforeStep, ...
            typecast(double(J.Steps{i}.stepLoad), 'uint8'), ...
            typecast(double(J.Steps{i}.stepSpeed), 'uint8'), ...
            typecast(uint32(1), 'uint8'), typecast(uint32(length(J.Steps{i}.SRRsteps)), 'uint8')
        ];
        
        for j = 1:numsteps(i)
            if (strcmpi(J.Steps{i}.SRRsteps{j}.type,'linear increments') || strcmpi(J.Steps{i}.SRRsteps{j}.type,'lininc'))
                disp(char(9)+"SRR step "+num2str(j)+" linear increments");
                ns = double(J.Steps{i}.SRRsteps{j}.endSRR-J.Steps{i}.SRRsteps{j}.startSRR)/double(J.Steps{i}.SRRsteps{j}.incrementSRR);
                if (floor(ns)==ns) % if not integer
                    warning("SRR increment does not result in integer of steps")
                end
                step{i,j} = [typecast(uint32(1), 'uint8'), ...
                    typecast(int64(J.Steps{i}.SRRsteps{j}.startSRR*(10^intCodedRealPrecision)), 'uint8'), ...
                    zeros(1,6), typecast(uint16(intCodedRealPrecision), 'uint8'), ...
                    typecast(int64(J.Steps{i}.SRRsteps{j}.endSRR*(10^intCodedRealPrecision)), 'uint8'), ...
                    zeros(1,6), typecast(uint16(intCodedRealPrecision), 'uint8'), ...
                    typecast(int64(J.Steps{i}.SRRsteps{j}.incrementSRR*(10^intCodedRealPrecision)), 'uint8'), ...
                    zeros(1,6), typecast(uint16(intCodedRealPrecision), 'uint8'), ...
                    uint8(ns), zeros(1,8)
                ];
            elseif (strcmpi(J.Steps{i}.SRRsteps{j}.type,'linear # steps') || strcmpi(J.Steps{i}.SRRsteps{j}.type,'linstep'))
                disp(char(9)+"SRR step "+num2str(j)+" linear # steps");
                J.Steps{i}.SRRsteps{j}.incrementSRR = double(J.Steps{i}.SRRsteps{j}.endSRR-J.Steps{i}.SRRsteps{j}.startSRR)/double(J.Steps{i}.SRRsteps{j}.numSteps);
                step{i,j} = [typecast(uint32(1), 'uint8'), ...
                    typecast(int64(J.Steps{i}.SRRsteps{j}.startSRR*(10^intCodedRealPrecision)), 'uint8'), ...
                    zeros(1,6), typecast(uint16(intCodedRealPrecision), 'uint8'), ...
                    typecast(int64(J.Steps{i}.SRRsteps{j}.endSRR*(10^intCodedRealPrecision)), 'uint8'), ...
                    zeros(1,6), typecast(uint16(intCodedRealPrecision), 'uint8'), ...
                    typecast(int64(J.Steps{i}.SRRsteps{j}.incrementSRR*(10^intCodedRealPrecision)), 'uint8'), ...
                    zeros(1,6), typecast(uint16(intCodedRealPrecision), 'uint8'), ...
                    J.Steps{i}.SRRsteps{j}.numSteps, zeros(1,4), 0x1, zeros(1,3)
                ];
            elseif (strcmpi(J.Steps{i}.SRRsteps{j}.type,'logarithmic') || strcmpi(J.Steps{i}.SRRsteps{j}.type,'log'))
                disp(char(9)+"SRR step "+num2str(j)+" logarithmic");
                step{i,j} = [typecast(uint32(1), 'uint8'), ...
                    typecast(int64(J.Steps{i}.SRRsteps{j}.startSRR*(10^intCodedRealPrecision)), 'uint8'), ...
                    zeros(1,6), typecast(uint16(intCodedRealPrecision), 'uint8'), ...
                    typecast(int64(J.Steps{i}.SRRsteps{j}.endSRR*(10^intCodedRealPrecision)), 'uint8'), ...
                    zeros(1,6), typecast(uint16(intCodedRealPrecision), 'uint8'), ...
                    zeros(1,16), J.Steps{i}.SRRsteps{j}.numSteps, zeros(1,3), 0x1, 0x1, zeros(1,3)
                ];
            else
                error("SRRstep type """ + J.Steps{i}.SRRsteps{j}.type + """ unsupported"+newline+ ...
                	char(9)+" supported values of Steps.SRRsteps.type are 'linstep', 'linear # steps', 'lininc', 'linear increments', 'log' and 'logarithmic'");
                return
            end
        end
    % Bidirectional Stribeck step
    elseif (strcmpi(J.Steps{i}.stepType,'Bidirectional Stribeck'))
        disp("Step "+num2str(i)+" Bidirectional Stribeck");
        if (~ iscell(J.Steps{i}.speedSteps))
            J.Steps{i}.speedSteps = {J.Steps{i}.speedSteps};
        end
        numsteps(i) = length(J.Steps{i}.speedSteps);
        StepHeadBytes = [typecast(uint32(11), 'uint8'), typecast(uint32(1), 'uint8')];
        Step{i} = [StepHeadBytes, ...
            typecast(uint32(i), 'uint8'), typecast(uint32(length(J.Steps)), 'uint8'), ...
            length(J.Steps{i}.stepName), uint8(J.Steps{i}.stepName), ...
            J.Steps{i}.tempCtrlEn, typecast(uint32(lubeProbe), 'uint8'), ...
            typecast(double(J.Steps{i}.tempCtrlTemp), 'uint8'), ...
            J.Steps{i}.waitForTempBeforeStep, ...
            typecast(double(J.Steps{i}.idleSpeed), 'uint8'), ...
            typecast(double(J.Steps{i}.idleLoad), 'uint8'), ...
            typecast(double(J.Steps{i}.idleSRR), 'uint8'), ...
            J.Steps{i}.unloadAtEnd, ECR, zeros(1,3), 0x1, zeros(1,7), ... % J.Steps{i}.measDiscTrackRadBeforeStep, ...
            typecast(double(J.Steps{i}.stepLoad), 'uint8'), ...
            typecast(double(J.Steps{i}.stepSRR), 'uint8'), ...
            typecast(uint32(1), 'uint8'), typecast(uint32(length(J.Steps{i}.speedSteps)), 'uint8')
        ];
        
        for j = 1:numsteps(i)
            if (strcmpi(J.Steps{i}.speedSteps{j}.type,'linear increments') || strcmpi(J.Steps{i}.speedSteps{j}.type,'lininc'))
                disp(char(9)+"Speed step "+num2str(j)+" linear increments");
                ns = double(J.Steps{i}.speedSteps{j}.endSpeed-J.Steps{i}.speedSteps{j}.startSpeed)/double(J.Steps{i}.speedSteps{j}.incrementSpeed);
                if (floor(ns)==ns) % if not integer
                    warning("Speed increment does not result in integer of steps")
                end
                step{i,j} = [typecast(uint32(1), 'uint8'), ...
                    typecast(int64(J.Steps{i}.speedSteps{j}.startSpeed*(10^intCodedRealPrecision)), 'uint8'), ...
                    zeros(1,6), typecast(uint16(intCodedRealPrecision), 'uint8'), ...
                    typecast(int64(J.Steps{i}.speedSteps{j}.endSpeed*(10^intCodedRealPrecision)), 'uint8'), ...
                    zeros(1,6), typecast(uint16(intCodedRealPrecision), 'uint8'), ...
                    typecast(int64(J.Steps{i}.speedSteps{j}.incrementSpeed*(10^intCodedRealPrecision)), 'uint8'), ...
                    zeros(1,6), typecast(uint16(intCodedRealPrecision), 'uint8'), ...
                    uint8(ns), zeros(1,8)
                ];
            elseif (strcmpi(J.Steps{i}.speedSteps{j}.type,'linear # steps') || strcmpi(J.Steps{i}.speedSteps{j}.type,'linstep'))
                disp(char(9)+"Speed step "+num2str(j)+" linear # steps");
                J.Steps{i}.speedSteps{j}.incrementSpeed = double(J.Steps{i}.speedSteps{j}.endSpeed-J.Steps{i}.speedSteps{j}.startSpeed)/double(J.Steps{i}.speedSteps{j}.numSteps);
                step{i,j} = [typecast(uint32(1), 'uint8'), ...
                    typecast(int64(J.Steps{i}.speedSteps{j}.startSpeed*(10^intCodedRealPrecision)), 'uint8'), ...
                    zeros(1,6), typecast(uint16(intCodedRealPrecision), 'uint8'), ...
                    typecast(int64(J.Steps{i}.speedSteps{j}.endSpeed*(10^intCodedRealPrecision)), 'uint8'), ...
                    zeros(1,6), typecast(uint16(intCodedRealPrecision), 'uint8'), ...
                    typecast(int64(J.Steps{i}.speedSteps{j}.incrementSpeed*(10^intCodedRealPrecision)), 'uint8'), ...
                    zeros(1,6), typecast(uint16(intCodedRealPrecision), 'uint8'), ...
                    J.Steps{i}.speedSteps{j}.numSteps, zeros(1,4), 0x1, zeros(1,3)
                ];
            elseif (strcmpi(J.Steps{i}.speedSteps{j}.type,'logarithmic') || strcmpi(J.Steps{i}.speedSteps{j}.type,'log'))
                disp(char(9)+"Speed step "+num2str(j)+" logarithmic");
                step{i,j} = [typecast(uint32(1), 'uint8'), ...
                    typecast(int64(J.Steps{i}.speedSteps{j}.startSpeed*(10^intCodedRealPrecision)), 'uint8'), ...
                    zeros(1,6), typecast(uint16(intCodedRealPrecision), 'uint8'), ...
                    typecast(int64(J.Steps{i}.speedSteps{j}.endSpeed*(10^intCodedRealPrecision)), 'uint8'), ...
                    zeros(1,6), typecast(uint16(intCodedRealPrecision), 'uint8'), ...
                    zeros(1,16), J.Steps{i}.speedSteps{j}.numSteps, zeros(1,3), 0x1, 0x1, zeros(1,3)
                ];
            else
                error("speedStep type """ + J.Steps{i}.speedSteps{j}.type + """ unsupported"+newline+ ...
                	char(9)+" supported values of Steps.SRRsteps.type are 'linstep', 'linear # steps', 'lininc', 'linear increments', 'log' and 'logarithmic'");
                return
            end
        end
    % Timed step
    elseif (strcmpi(J.Steps{i}.stepType,'Timed'))
        disp("Step "+num2str(i)+" Timed");
        StepHeadBytes = [typecast(uint32(2), 'uint8'), typecast(uint32(1), 'uint8')];
        Step{i} = [StepHeadBytes, ...
            typecast(uint32(i), 'uint8'), typecast(uint32(length(J.Steps)), 'uint8'), ...
            length(J.Steps{i}.stepName), uint8(J.Steps{i}.stepName), ...
            J.Steps{i}.tempCtrlEn, typecast(uint32(lubeProbe), 'uint8'), ...
            typecast(double(J.Steps{i}.startTemp), 'uint8'), ...
            J.Steps{i}.waitForTempBeforeStep, ...
            typecast(double(J.Steps{i}.idleSpeed), 'uint8'), ...
            typecast(double(J.Steps{i}.idleLoad), 'uint8'), ...
            typecast(double(J.Steps{i}.idleSRR), 'uint8'), ...
            J.Steps{i}.unloadAtEnd
        ];
        if (mtm_etm ~= 'e'); Step{i} = [Step{i}, ECR, zeros(1,3)]; end % ETM has no ECR
        Step{i} = [Step{i}, 0x1, zeros(1,7), ...
            typecast(uint64(J.Steps{i}.stepDurationSeconds*(10^7)), 'uint8'), ...
            J.Steps{i}.logData, ...
            typecast(uint64(J.Steps{i}.logDataIntervalSeconds*(10^7)), 'uint8'), ...
            typecast(double(J.Steps{i}.startTemp), 'uint8'), ...
            typecast(double(J.Steps{i}.endTemp), 'uint8'), ...
            typecast(double(J.Steps{i}.startLoad), 'uint8'), ...
            typecast(double(J.Steps{i}.endLoad), 'uint8'), ...
            typecast(double(J.Steps{i}.startSpeed), 'uint8'), ...
            typecast(double(J.Steps{i}.endSpeed), 'uint8'), ...
            typecast(double(J.Steps{i}.startSRR), 'uint8'), ...
            typecast(double(J.Steps{i}.endSRR), 'uint8'), ...
        ];
    % Mapper step
    elseif (strcmpi(J.Steps{i}.stepType,'Mapper'))
        disp("Step "+num2str(i)+" Mapper");
        if (mtm_etm=='e') % ETM has different Mapper header
            StepHeadBytes = [typecast(uint32(3), 'uint8'), typecast(uint32(1), 'uint8')];
        else
            StepHeadBytes = [typecast(uint32(8), 'uint8'), typecast(uint32(1), 'uint8')];
        end
        Step{i} = [StepHeadBytes, ...
            typecast(uint32(i), 'uint8'), typecast(uint32(length(J.Steps)), 'uint8'), ...
            length(J.Steps{i}.stepName), uint8(J.Steps{i}.stepName), ...
            J.Steps{i}.tempCtrlEn, typecast(uint32(lubeProbe), 'uint8'), ...
            typecast(double(J.Steps{i}.tempCtrlTemp), 'uint8'), ...
            J.Steps{i}.waitForTempBeforeStep, ...
            typecast(double(J.Steps{i}.idleSpeed), 'uint8'), ... % idle Load and SRR zeroed for safety
            zeros(1,16), 1
        ];
        if (mtm_etm ~= 'e'); Step{i} = [Step{i}, ECR, zeros(1,3)]; end % ETM has no ECR
        Step{i} = [Step{i}, 0x1, zeros(1,3), ...
            typecast(double(J.Steps{i}.windowLoad), 'uint8'), ...
        ];
    % Suspend
    elseif (strcmpi(J.Steps{i}.stepType,'Suspend'))
        disp("Step "+num2str(i)+" Suspend");
        if (mtm_etm=='e') % ETM has different Suspend header
            StepHeadBytes = [typecast(uint32(4), 'uint8'), typecast(uint32(1), 'uint8')];
        else
            StepHeadBytes = [typecast(uint32(9), 'uint8'), typecast(uint32(1), 'uint8')];
        end
        Step{i} = [StepHeadBytes, ...
            typecast(uint32(i), 'uint8'), typecast(uint32(length(J.Steps)), 'uint8'), ...
            0, J.Steps{i}.tempCtrlEn, typecast(uint32(lubeProbe), 'uint8'), ...
            typecast(double(J.Steps{i}.tempCtrlTemp), 'uint8'), ...
            J.Steps{i}.waitForTempBeforeStep, ...
            typecast(double(J.Steps{i}.idleSpeed), 'uint8'), ...
            typecast(double(J.Steps{i}.idleLoad), 'uint8'), ...
            typecast(double(J.Steps{i}.idleSRR), 'uint8'), ...
            J.Steps{i}.unloadAtEnd
        ];
        if (mtm_etm ~= 'e'); Step{i} = [Step{i}, ECR, zeros(1,3)]; end % ETM has no ECR
        Step{i} = [Step{i}, 0x1, zeros(1,3), ...
            length(J.Steps{i}.stepText), uint8(J.Steps{i}.stepText)
        ];
    else
        error("stepType """ + J.Steps{i}.stepType + """ unsupported")
    end
end

% write byte arrays
fwrite(f, Header, 'uint8');
for i = 1:length(J.Steps)
    fwrite(f, Step{i}, 'uint8');
    if (strcmpi(J.Steps{i}.stepType,'Traction') || ...
        strcmpi(J.Steps{i}.stepType,'Stribeck') || ...
        strcmpi(J.Steps{i}.stepType,'Bidirectional Traction') || ...
        strcmpi(J.Steps{i}.stepType,'Bidirectional Stribeck'))
        for j = 1:numsteps(i)
            fwrite(f, step{i,j}, 'uint8');
        end
    end
end

fclose(f);
